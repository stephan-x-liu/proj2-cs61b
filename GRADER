                                     GRADER

Name of student running submit: Stephan Liu
Login of student running submit: cs61b-wf

Second team member's name: Amanda Chow
Second team member's login:

Third team member's name (if any): Sebastian Merz
Third team member's login:

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?


Have you tested your program on the 61B lab machines?


Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor (or is it a variable-depth search)?


Describe your board evaluation function in some detail.


Does your MachinePlayer use any special method of choosing the first few moves?


Is there anything else the graders should know to help them read your project?



Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).  (If you're using a list class, that should probably count as
     a separate module.)
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces will be worth 10% of your
grade.

Classes:
Field.java
Piece.java
Grid.java
MachinePlayer.java


=================================MODULES=================================

- Grid: Class representation of current state of the game.
- Move: Finds valid moves
- Network: Finds existing networks or potential networks
- AlphaBeta: Performs Alpha-Beta Pruning
- Eval: Evaluates a score for each board 





================================GRID MODULE================================

Classes:

  - Grid.java: Represents game grid
  - Field.java: Represents wrapper for a field
  - Piece.java: Represents a piece, either black or white

  -------------------------------Grid.java-------------------------------

  Fields:

    private Field[][] grid //2D Square array size 7 x 7 of all Squares in grid

    private boolean addMove //'true' if players are currently performing add moves
    
    private Field[] machineSquares //Square array size 10 of Squares claimed by opponent
    
    private Field[] opponentSquares //Square array size 10 of Squares claimed by opponent

  Methods:

    public char moveType() //Return "A," "S," or "Q" according to what type of move the next move should be

    public void machineMove(Move) //Changes machineSquares accordingly based on MachinePlayer's move

    public void opponentMove(Move) //Changes opponentSquares accordingly based on OpponentPlayer's move

    public void removeSquare(int[] coord) //Takes in coordinate of square and sets it to unclaimed

    public Grid clone(Grid) //Clones current Grid onto new Grid


  ------------------------------Field.java------------------------------
  
  /**
  * Constructor for Field object.
  * @param x is x coordinate of field.
  * @param y is y coordinate of field.
  * @param g is Grid that the field is on.
  **/
  public Field( int x, int y, Grid g)

  /**
  * Gets the coordinates of the Field.
  * @return is a length 2 integer array contain x and y.
  **/
  public int[] position()

  /**
  * Sets the piece of a Field.
  * @param p is the Piece that is being placed in the field.
  **/
  public void setPiece(Piece p)

  /**
  * Gets the piece a field contains.
  * @return is a piece if Field is occupied.
  *  @return is null if Field is unoccupied.
  **/
  public Piece getPiece()

  /**
  * Returns whether or not the Field has a piece.
  * @return true if occupied and false if unoccupied.
  **/
  public boolean hasPiece()

  /**
  * Gets a Field in an adjacdent direction
  * @param dir is a length 2 integer array defining direction.
  * @return is a Field if there is a valid Field in the direction.
  *  @return is null if out of bounds of Grid.
  **/
  public Field adjacent(int[] dir)

  /**
  * Checks if Field as one neighbor.
  * @return is a Field if there is a neighbor (occupied adjacent Field).
  *  @return is null if there is not a neighbor.
  **/
  public Field neighbor()

  /**
  * Finds closest piece in given direction.
  * @param dir is a length 2 integer array defining direction.
  * @return is a Field if there is an occupied Field in the given direction.
  * @return null if it hits the edge of the Grid.
  **/
  public Field getInDirection(int[] dir)

  /**
  * Removes the piece of a Field.
  **/
  public void removePiece()


================================MOVE MODULE================================

Classes:

  - Grid.java

  -------------------------------Grid.java-------------------------------

  Methods:

    public boolean isValidMove(Move move) //Returns true if move is valid, false if move is invalid.

    public Moves[] validAddMoves() //Return list of valid add moves for MachinePlayer

    public Moves[] validStepMoves() //Return list of valid step moves for MachinePlayer





===============================NETWORK MODULE===============================

Classes:

  - Grid.java

  -------------------------------Grid.java-------------------------------

  Methods:

    public char hasNetwork() //Return 'M' if Grid contains a MachinePlayer network, 'O' if Grid contains an opponent player network, 'N' if Grid doesn't contain a network





==============================ALPHABETA MODULE==============================

Classes:

- Grid.java

  -------------------------------Grid.java-------------------------------

  Fields:

    - private int searchDepth //Search depth of Alpha-Beta Pruning

  Methods:

    public Move addABPruning(boolean machineTurn=true) //Returns best Add move using Alpha-Beta Pruning. Takes boolean parameter that is true if calculating for MachinePlayer's move, false if calculating for opponent's move

    public Move stepABPruning(boolean machineTurn=true) //Returns best Step move using Alpha-Beta Pruning. Takes boolean parameter that is true if calculating for MachinePlayer's move, false if calculating for opponent's move





================================EVAL MODULE================================

Classes:

- Grid.java

-------------------------------Grid.java-------------------------------

  Methods:

    public int eval() //Returns evaluation of Grid--Positive value if MachinePlayer is doing well, negative value if MachinePlayer is not.


Modules:












